"""
recomp.py - Civilization Static Recompilation Driver

Main pipeline: decode → analyze → lift → output C files.

Reads CIV.EXE, detects all functions in resident code and overlays,
lifts each function to C, and writes compilable output files split
across multiple .c files for parallel compilation.

Part of the Civ Recomp project (sp00nznet/civ)
"""

import os
import sys
import struct
from decode16 import Decoder
from analyze import Analyzer
from lift import Lifter


HEADER = """\
/*
 * {filename} - Recompiled Civilization code
 *
 * AUTO-GENERATED by recomp.py - DO NOT EDIT
 * Source: CIV.EXE (Sid Meier's Civilization, 1991)
 *
 * Part of the Civ Recomp project (sp00nznet/civ)
 */

#include "recomp/cpu.h"

/* Forward declarations */
{forward_decls}

/* DOS/BIOS interrupt handlers (implemented in dos_compat.c) */
extern void dos_int21(CPU *cpu);
extern void bios_int10(CPU *cpu);
extern void bios_int16(CPU *cpu);
extern void mouse_int33(CPU *cpu);
extern void int_handler(CPU *cpu, uint8_t num);

/* Port I/O (implemented in dos_compat.c) */
extern void port_out8(CPU *cpu, uint16_t port, uint8_t value);
extern uint8_t port_in8(CPU *cpu, uint16_t port);

"""


def recompile(exe_path: str, output_dir: str, funcs_per_file: int = 50):
    """Run the full recompilation pipeline."""

    print("=" * 60)
    print("  Civilization Static Recompiler")
    print("  CIV.EXE -> C code")
    print("=" * 60)

    # Load binary
    with open(exe_path, 'rb') as f:
        data = f.read()
    print(f"\nLoaded {exe_path} ({len(data)} bytes)")

    # Analyze
    print("\n--- Phase 1: Analysis ---")
    analyzer = Analyzer(data)
    analyzer.find_overlays()
    analyzer.detect_all_functions()
    analyzer.extract_strings()
    print(f"Found {len(analyzer.functions)} functions, "
          f"{sum(f.inst_count for f in analyzer.functions)} instructions")

    # Build overlay base address map (overlay_num -> code_offset)
    overlay_bases = {}
    for ovl in analyzer.overlays:
        overlay_bases[ovl.index] = ovl.code_offset

    # Build known function address -> name map (for resolving far calls)
    known_funcs = {}
    for func in analyzer.functions:
        known_funcs[func.start] = func.name

    hdr_size = analyzer.hdr_size

    # Lift each function
    print("\n--- Phase 2: Lifting ---")
    os.makedirs(output_dir, exist_ok=True)

    all_lifted = []
    all_names = set()
    errors = 0

    for func in sorted(analyzer.functions, key=lambda f: f.start):
        # Decode instructions for this function
        code = data[func.start:func.end]
        decoder = Decoder(code, base_offset=func.start)
        instructions = decoder.decode_range(0, len(code))

        # Lift
        lifter = Lifter(overlay_bases=overlay_bases, hdr_size=hdr_size,
                         known_funcs=known_funcs)
        try:
            c_code = lifter.lift_function(
                func.name, instructions, func.start, func.is_far)
            all_lifted.append((func, c_code, lifter.func_calls, lifter.ovl_calls))
            all_names.add(func.name)
        except Exception as e:
            print(f"  Error lifting {func.name}: {e}")
            errors += 1

    print(f"Lifted {len(all_lifted)} functions ({errors} errors)")

    # Collect all referenced function names for forward declarations
    all_referenced = set()
    for func, code, calls, ovl_calls in all_lifted:
        all_referenced.update(calls)
        all_referenced.update(ovl_calls)
    all_referenced.update(all_names)

    forward_decls = '\n'.join(
        f'void {name}(CPU *cpu);'
        for name in sorted(all_referenced)
    )

    # Write output files (split across multiple .c files)
    print(f"\n--- Phase 3: Output ---")

    file_idx = 0
    func_idx = 0
    total_files = 0

    while func_idx < len(all_lifted):
        batch = all_lifted[func_idx:func_idx + funcs_per_file]
        func_idx += funcs_per_file

        filename = f'civ_recomp_{file_idx:03d}.c'
        filepath = os.path.join(output_dir, filename)

        with open(filepath, 'w') as out:
            out.write(HEADER.format(
                filename=filename,
                forward_decls=forward_decls,
            ))
            for func, code, calls, ovl_calls in batch:
                out.write(f'\n/* Function: {func.name}\n')
                out.write(f' * Original: 0x{func.start:06X} - 0x{func.end:06X} '
                          f'({func.size} bytes, {func.inst_count} instructions)\n')
                if func.is_overlay:
                    out.write(f' * Overlay:  {func.overlay_num}\n')
                out.write(f' */\n')
                out.write(code)
                out.write('\n\n')

        total_files += 1
        file_idx += 1
        funcs_in_file = len(batch)
        print(f"  {filename}: {funcs_in_file} functions")

    # Generate stubs for unresolved symbols (functions referenced but not defined)
    unresolved = all_referenced - all_names

    # Exclude functions that have hand-written implementations in civ_impl.c
    # or civ_aliases.c (these files are not auto-generated)
    impl_funcs = set()
    for impl_file in ['civ_impl.c', 'civ_aliases.c']:
        impl_path = os.path.join(output_dir, impl_file)
        if os.path.exists(impl_path):
            import re
            with open(impl_path, 'r') as f:
                for match in re.finditer(r'^void\s+(\w+)\s*\(', f.read(), re.MULTILINE):
                    impl_funcs.add(match.group(1))
    if impl_funcs:
        unresolved -= impl_funcs
        print(f"  Excluded {len(impl_funcs)} functions with hand-written implementations")

    if unresolved:
        stub_file = os.path.join(output_dir, 'civ_stubs.c')
        with open(stub_file, 'w') as out:
            out.write('/*\n * civ_stubs.c - Stub functions for unresolved symbols\n')
            out.write(' * AUTO-GENERATED by recomp.py\n')
            out.write(' *\n * These functions are referenced by the recompiled code but were\n')
            out.write(' * not detected by the function boundary analyzer. They may be:\n')
            out.write(' *   - C library routines (MSC 5.x runtime)\n')
            out.write(' *   - Functions without standard prologues\n')
            out.write(' *   - Cross-segment far call targets\n')
            out.write(' * Each stub logs a warning when called.\n')
            out.write(' */\n\n')
            out.write('#include "recomp/cpu.h"\n')
            out.write('#include <stdio.h>\n\n')
            for name in sorted(unresolved):
                out.write(f'void {name}(CPU *cpu) {{\n')
                out.write(f'    (void)cpu;\n')
                out.write(f'    static int _warned = 0;\n')
                out.write(f'    if (!_warned) {{ fprintf(stderr, "[STUB] {name} called\\n"); _warned = 1; }}\n')
                out.write(f'}}\n\n')
        print(f"  civ_stubs.c: {len(unresolved)} stub functions")

    # Write master header
    header_path = os.path.join(output_dir, 'civ_recomp.h')
    with open(header_path, 'w') as out:
        out.write('/* civ_recomp.h - Master header for recompiled Civilization code\n')
        out.write(' * AUTO-GENERATED by recomp.py\n */\n\n')
        out.write('#ifndef CIV_RECOMP_H\n#define CIV_RECOMP_H\n\n')
        out.write('#include "recomp/cpu.h"\n\n')
        out.write('/* All recompiled functions */\n')
        for name in sorted(all_names):
            out.write(f'void {name}(CPU *cpu);\n')
        out.write(f'\n/* Entry point (resident code startup) */\n')
        # Find the entry point function
        entry_cs = struct.unpack_from('<H', data, 22)[0]
        entry_ip = struct.unpack_from('<H', data, 20)[0]
        hdr_size = struct.unpack_from('<H', data, 8)[0] * 16
        entry_off = hdr_size + entry_cs * 16 + entry_ip
        entry_name = f'res_{entry_off:06X}'
        out.write(f'#define CIV_ENTRY_POINT {entry_name}\n\n')
        out.write('#endif /* CIV_RECOMP_H */\n')

    # Summary
    total_instructions = sum(f.inst_count for f, _, _, _ in all_lifted)
    total_code_bytes = sum(f.size for f, _, _, _ in all_lifted)

    print(f"\n--- Summary ---")
    print(f"  Functions:     {len(all_lifted)}")
    print(f"  Instructions:  {total_instructions}")
    print(f"  Code bytes:    {total_code_bytes} ({total_code_bytes/1024:.1f} KB)")
    print(f"  Output files:  {total_files} .c files + 1 .h file")
    print(f"  Output dir:    {output_dir}")
    print(f"  Errors:        {errors}")


def main():
    if len(sys.argv) < 2:
        print("Usage: recomp.py <civ.exe> [output_dir] [funcs_per_file]")
        print("\nFull static recompilation pipeline.")
        print("Outputs compilable C code from CIV.EXE.")
        sys.exit(1)

    exe_path = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) >= 3 else 'RecompiledFuncs'
    funcs_per_file = int(sys.argv[3]) if len(sys.argv) >= 4 else 50

    recompile(exe_path, output_dir, funcs_per_file)


if __name__ == '__main__':
    main()
