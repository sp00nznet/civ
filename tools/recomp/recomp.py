"""
recomp.py - Civilization Static Recompilation Driver

Main pipeline: decode → analyze → lift → output C files.

Reads CIV.EXE, detects all functions in resident code and overlays,
lifts each function to C, and writes compilable output files split
across multiple .c files for parallel compilation.

Part of the Civ Recomp project (sp00nznet/civ)
"""

import os
import sys
import struct
from decode16 import Decoder
from analyze import Analyzer
from lift import Lifter


HEADER = """\
/*
 * {filename} - Recompiled Civilization code
 *
 * AUTO-GENERATED by recomp.py - DO NOT EDIT
 * Source: CIV.EXE (Sid Meier's Civilization, 1991)
 *
 * Part of the Civ Recomp project (sp00nznet/civ)
 */

#include "recomp/cpu.h"

/* Forward declarations */
{forward_decls}

/* DOS/BIOS interrupt handlers (implemented in dos_compat.c) */
extern void dos_int21(CPU *cpu);
extern void bios_int10(CPU *cpu);
extern void bios_int16(CPU *cpu);
extern void mouse_int33(CPU *cpu);
extern void int_handler(CPU *cpu, uint8_t num);

"""


def recompile(exe_path: str, output_dir: str, funcs_per_file: int = 50):
    """Run the full recompilation pipeline."""

    print("=" * 60)
    print("  Civilization Static Recompiler")
    print("  CIV.EXE -> C code")
    print("=" * 60)

    # Load binary
    with open(exe_path, 'rb') as f:
        data = f.read()
    print(f"\nLoaded {exe_path} ({len(data)} bytes)")

    # Analyze
    print("\n--- Phase 1: Analysis ---")
    analyzer = Analyzer(data)
    analyzer.find_overlays()
    analyzer.detect_all_functions()
    analyzer.extract_strings()
    print(f"Found {len(analyzer.functions)} functions, "
          f"{sum(f.inst_count for f in analyzer.functions)} instructions")

    # Lift each function
    print("\n--- Phase 2: Lifting ---")
    os.makedirs(output_dir, exist_ok=True)

    all_lifted = []
    all_names = set()
    errors = 0

    for func in sorted(analyzer.functions, key=lambda f: f.start):
        # Decode instructions for this function
        code = data[func.start:func.end]
        decoder = Decoder(code, base_offset=func.start)
        instructions = decoder.decode_range(0, len(code))

        # Lift
        lifter = Lifter()
        try:
            c_code = lifter.lift_function(
                func.name, instructions, func.start, func.is_far)
            all_lifted.append((func, c_code, lifter.func_calls, lifter.ovl_calls))
            all_names.add(func.name)
        except Exception as e:
            print(f"  Error lifting {func.name}: {e}")
            errors += 1

    print(f"Lifted {len(all_lifted)} functions ({errors} errors)")

    # Collect all referenced function names for forward declarations
    all_referenced = set()
    for func, code, calls, ovl_calls in all_lifted:
        all_referenced.update(calls)
        all_referenced.update(ovl_calls)
    all_referenced.update(all_names)

    forward_decls = '\n'.join(
        f'void {name}(CPU *cpu);'
        for name in sorted(all_referenced)
    )

    # Write output files (split across multiple .c files)
    print(f"\n--- Phase 3: Output ---")

    file_idx = 0
    func_idx = 0
    total_files = 0

    while func_idx < len(all_lifted):
        batch = all_lifted[func_idx:func_idx + funcs_per_file]
        func_idx += funcs_per_file

        filename = f'civ_recomp_{file_idx:03d}.c'
        filepath = os.path.join(output_dir, filename)

        with open(filepath, 'w') as out:
            out.write(HEADER.format(
                filename=filename,
                forward_decls=forward_decls,
            ))
            for func, code, calls, ovl_calls in batch:
                out.write(f'\n/* Function: {func.name}\n')
                out.write(f' * Original: 0x{func.start:06X} - 0x{func.end:06X} '
                          f'({func.size} bytes, {func.inst_count} instructions)\n')
                if func.is_overlay:
                    out.write(f' * Overlay:  {func.overlay_num}\n')
                out.write(f' */\n')
                out.write(code)
                out.write('\n\n')

        total_files += 1
        file_idx += 1
        funcs_in_file = len(batch)
        print(f"  {filename}: {funcs_in_file} functions")

    # Write master header
    header_path = os.path.join(output_dir, 'civ_recomp.h')
    with open(header_path, 'w') as out:
        out.write('/* civ_recomp.h - Master header for recompiled Civilization code\n')
        out.write(' * AUTO-GENERATED by recomp.py\n */\n\n')
        out.write('#ifndef CIV_RECOMP_H\n#define CIV_RECOMP_H\n\n')
        out.write('#include "recomp/cpu.h"\n\n')
        out.write('/* All recompiled functions */\n')
        for name in sorted(all_names):
            out.write(f'void {name}(CPU *cpu);\n')
        out.write(f'\n/* Entry point (resident code startup) */\n')
        # Find the entry point function
        entry_cs = struct.unpack_from('<H', data, 22)[0]
        entry_ip = struct.unpack_from('<H', data, 20)[0]
        hdr_size = struct.unpack_from('<H', data, 8)[0] * 16
        entry_off = hdr_size + entry_cs * 16 + entry_ip
        entry_name = f'res_{entry_off:06X}'
        out.write(f'#define CIV_ENTRY_POINT {entry_name}\n\n')
        out.write('#endif /* CIV_RECOMP_H */\n')

    # Summary
    total_instructions = sum(f.inst_count for f, _, _, _ in all_lifted)
    total_code_bytes = sum(f.size for f, _, _, _ in all_lifted)

    print(f"\n--- Summary ---")
    print(f"  Functions:     {len(all_lifted)}")
    print(f"  Instructions:  {total_instructions}")
    print(f"  Code bytes:    {total_code_bytes} ({total_code_bytes/1024:.1f} KB)")
    print(f"  Output files:  {total_files} .c files + 1 .h file")
    print(f"  Output dir:    {output_dir}")
    print(f"  Errors:        {errors}")


def main():
    if len(sys.argv) < 2:
        print("Usage: recomp.py <civ.exe> [output_dir] [funcs_per_file]")
        print("\nFull static recompilation pipeline.")
        print("Outputs compilable C code from CIV.EXE.")
        sys.exit(1)

    exe_path = sys.argv[1]
    output_dir = sys.argv[2] if len(sys.argv) >= 3 else 'RecompiledFuncs'
    funcs_per_file = int(sys.argv[3]) if len(sys.argv) >= 4 else 50

    recompile(exe_path, output_dir, funcs_per_file)


if __name__ == '__main__':
    main()
